# 一 数据结构
## 1.1基础知识
数据对象（D）+数据对象之间的关系（S）
$$DataStatus = (D,S)$$
### 1.1.1 概念
#### 1.1.1.1物理储存
数据对象的存储方式是二进制，关系的存储方式是有序对。
类型：
- 顺序存储：相对位置表示后继关系
- 链式存储：附加信息（指针）表示后继关系
数据对象->数据元素（数据对象中的个体）->数据项（数据元素的相关属性）
#### 1.1.1.2数据类型
数据的定义域和操作集
*抽象数据类型*
数据对象+数据关系+操作集$ADT=D+S+P$
```C++
ADT typename{
	 数据类型：D={...}
	 数据关系：S={...}
	 操作集；
		一些函数操作
}ADT typename
```
--- 参数类型 --- 
- 赋值参数
- 引用参数
### 1.1.2逻辑结构类型
1. 线性结构：
	1. 数组`array`
	2. 链表`linked list`
	3. 栈`stack`
	4. 队列`queue`
2. 非线性结构：
	1. 数`tree`
	2. 图`graph`
	3. 堆`heap`
3. 哈希表`hash table`
### 1.1.3基本数据结构
- 整数类型 `byte`、`short`、`int`、`long` 。
- 浮点数类型 `float`、`double` ，用于表示小数。
- 字符类型 `char` ，用于表示各种语言的字母、标点符号、甚至表情符号等。
- 布尔类型 `bool` ，用于表示“是”与“否”判断。
## 1.2 数组与列表

### 1.2.1数组
常见操作：
1. 初始化数组
```C++
int aArray[3] = {12,3,4};  
int *bArray = new int[3];
```

```Java
int[] array = new int[4];
```

```Python
arr: list[int] = [1,2,3,4]
```
2. 访问元素
3. 插入元素
4. 删除元素
5. 遍历数组
6. 查找元素
7. 扩容数组

# 二 算法
## 2.1基础知识
算法及为对数据进行`增删改查`（CRUD），对于算法的评判有两种复杂度：空间复杂度$S(n)$，时间复杂度$T(n)$ 。其中对于时间复杂度的表示方式有两种：直接表示法，渐进表示法，
### 2.1.1渐进表示法
其中渐进表示法即为只与数据规模$n$有关，与机器或编译无关。
对应的概念：
- 渐进上界：$T(n)=O(g(n)),\exists{c>0,n_0>0},s.t.n\geqslant{n_0},T(n)\geqslant{c\cdot{g(n)}}$
- 渐进下界：$T(n)=\Omega{(g(n))},\exists{c>0,n_0>0},s.t.n\geqslant{n_0},T(n)\leqslant{c\cdot{g(n)}}$
- 渐进确界：$T(n)=O(g(n))且T(n)=\Omega{(g(n))}$
计算方式：
- 嵌套：$O(n)=(\prod_{i=1}^{m}n_i)\cdot{a},m为循环体个数，n_i为第i个循环体的规模，a为循环体内的复杂度$
- 判断：$O(n)=max(O(f_1),O(f_2),\cdots{O(f_n)})$
### 2.1.2前缀和

进行预处理，降低时间复杂度。$y_n=y_{n-1}+x_n$
一维数组前缀和
```c++
//一维数组进行
for(int i = 0; i < n; i++ ){
	if(i == 0){
		y[i] = x [i];
	}else{
		y[i] = y[i-1] + x[i];
	}
}
```
二维数组前缀和
```C++
for(int i = 0;i < n;i++){
	for(int j = 0;j < m;j++){
		if(x == 0 && y == 0){
			b[i][j] = a[i][j];
		}else if(x == 0){
			b[i][j] = a[i][j] + b[i-1][j];
		}else if(y == 0){
			b[i][j] = a[i][j] + b[i][j-1];
		}else{
			b[i][j] = b[i-1][j] + b[i][j-1] - b[i-1][i-1] + a[i][j];
		}
	}
}
```
## 2.2递归
本质上看，递归体现“将问题分解为更小子问题”的思维范式，这种分治策略是至关重要的。
### 2.2.1普通递归
```C++
int recur(int n) {
    // 终止条件
    if (n == 1)
        return 1;
    return n + recur(n - 1);
}
```
### 2.2.2尾递归
大部分语言支持尾递归实现递n次归1次（Python默认不支持尾递归）
```C++
int recursion_2(int n, int res){
    if(n==0){
        return res;
    }
    //返回结果不需要在每次递归后进行操作
    return recursion_2(n-1, n+res);
}
```


